<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lógica combinacional</title>
    <meta charset="utf-8" />
    <meta name="author" content="Josué Meneses Díaz" />
    <meta name="author" content="josue.meneses@usach.cl" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/fabric/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/xaringanExtra-extra-styles/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/fira_sans.css" type="text/css" />
    <link rel="stylesheet" href="css/fira_code.css" type="text/css" />
    <link rel="stylesheet" href="css/personal.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Lógica combinacional
## Electrónica digital y microcontroladores
### Josué Meneses Díaz
### <a href="mailto:josue.meneses@usach.cl" class="email">josue.meneses@usach.cl</a>
### Universidad de Santiago de Chile
### 04-06-2021

---


# Objetivos 
&lt;br&gt; &lt;br&gt;
- Conocer los principios de los fundamentos del algebra booleana.
  - Teoremas Booleanos
  - Teoremas De Morgan
- Métodos de Diseño para Circuitos combinacionales 
  - Algebra Booleana
  - Método 1. Minterm/Maxterm
  - Método 2. Mapas de Karnaugh

---
# Logica combinacional
.fl.w-50.pa2[
&lt;br&gt; &lt;br&gt;
- Es aquel circuito lógico que implementa una o varias funciones lógicas.
  - Entradas 0, 1 -&gt; Salidas  0, 1
&lt;br&gt;
- Las salidas solo dependen de las entradas del sistema.
  - **NO TIENE MEMORIA**
]

.fl.w-50.pa2[
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./images/02.2/7402.png" alt="Esquema Puerta lógica 7402" width="60%" /&gt;
&lt;p class="caption"&gt;Esquema Puerta lógica 7402&lt;/p&gt;
&lt;/div&gt;
]
---
# Descripción Estructural
.fl.w-40.pa2[
- Describe como se encuentra internamente definido un circuito lógico combinacional por medio de puertas lógicas.
- Nos permite encontrar ***una*** la función booleana del sistema de forma simple.
]
.fl.w-60.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Encontrar una expresión en la salida de las puertas (Y)
]

&lt;img src="./images/04.1/ejemplo1.png" width="60%" style="display: block; margin: auto;" /&gt;

]
???
$$
f(A,B,C)=A\cdot B\cdot \bar{C}+\bar{A}\cdot B\cdot C
$$
---
# Tipos de descripciones
.fl.w-50.pa2[
## Descripción Estructural
&lt;img src="./images/04.1/ejemplo1.png" width="60%" style="display: block; margin: auto;" /&gt;
&lt;br&gt; &lt;br&gt;
$$
f(A,B,C)=A\cdot B\cdot \bar{C}+\bar{A}\cdot B\cdot C
$$
]


.fl.w-50.pa2[
## Descripción Funcional
.panelset[
.panel[.panel-name[Tabla]
&lt;img src="./images/04.1/tb1.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tb1_resp.svg" width="80%" style="display: block; margin: auto;" /&gt;
]]
]
???
&lt;img src="./images/04.1/tb1_resp.svg" width="80%" style="display: block; margin: auto;" /&gt;
---
class: clear, center, middle

.font120[**¿Cómo podemos pasar de una descripción funcional a una estructural?**]

--

.font120[**¿Cómo podemos deducimos una función booleana desde una tabla de verdad?**]

--
.fl.w-40.pa2[
- Minitérminos/Maxitérminos   
- Mapas de Karnaugh (k-maps)
]
.fl.w-60.pa2[
&lt;img src="./images/04.1/esquema1.svg" width="60%" style="display: block; margin: auto;" /&gt;

]

---
class: inverse, middle, center
# Algebra booleana

---
# Teoremas Booleanos
Son los teoremas que conocemos de álgebra, ahora aplicados sobre circuitos lógicos.

.fl.w-60.pa2[

&lt;img src="./images/04.1/teoremas_booleanos.svg" width="140%" style="display: block; margin: auto;" /&gt;
]

---
# Teoremas de De Morgan
## T1. `\(\overline{A\cdot B}=\bar{A}+\bar{B}\)`
.fl.w-60.pa2[
.panelset[.panel[.panel-name[DeMorgan 1]
&lt;img src="./images/04.1/tbDeMorgan_T1.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tbDeMorgan_T1_sol.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
]]

.fl.w-40.pa2[
&lt;img src="./images/04.1/DeMorgan_T1.png" width="80%" style="display: block; margin: auto;" /&gt;
]
???
&lt;img src="./images/04.1/tbDeMorgan_T1_sol.svg" width="80%" style="display: block; margin: auto;" /&gt;

---
# Teoremas de De Morgan
## T2. `\(\overline{ A+B}=\bar{A}\cdot \bar{B}\)`
.fl.w-60.pa2[
.panelset[.panel[.panel-name[DeMorgan 2]
&lt;img src="./images/04.1/tbDeMorgan_T2.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tbDeMorgan_T2_sol.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
]]

.fl.w-40.pa2[
&lt;img src="./images/04.1/DeMorgan_T2.png" width="80%" style="display: block; margin: auto;" /&gt;
]
???
&lt;img src="./images/04.1/tbDeMorgan_T2_sol.svg" width="80%" style="display: block; margin: auto;" /&gt;
---
# Teoremas de De Morgan - Procedimiento
.fl.w-40.pa2[
1. Complementar toda la expresión
2. Cambiar la función entre cada termino
3. Complementar cada término
]
.fl.w-60.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Aplicar los teoremas de De Morgan a la expresión `\(𝐴+𝐵\)`. Dibuje ambos esquemas equivalentes.
]
.panelset[.panel[.panel-name[desarrollo]

]
.panel[.panel-name[sol]

`\begin{aligned}
  f(A,B)&amp;=A+B=\overline{\bar{A}\cdot \bar{B}}\\
  (1) &amp;\: \overline{A+B}\\
  (2)&amp;\: \overline{A\cdot B}\\
  (3)&amp;\: \overline{\bar{A}\cdot \bar{B}}\\
\end{aligned}`

]]]
???
`\begin{aligned}
  f(A,B)&amp;=A+B=\overline{\bar{A}\cdot \bar{B}}\\
  (1) &amp;\: \overline{A+B}\\
  (2)&amp;\: \overline{A\cdot B}\\
  (3)&amp;\: \overline{\bar{A}\cdot \bar{B}}\\
\end{aligned}`
---
# Teoremas de De Morgan - Procedimiento
.fl.w-40.pa2[
1. Complementar toda la expresión
2. Cambiar la función entre cada termino
3. Complementar cada término
]
.fl.w-60.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Aplicar los teoremas de De Morgan a la expresión `\(\overline{𝐴\cdot𝐵}\)`. Dibuje ambos esquemas equivalentes.
]
.panelset[.panel[.panel-name[desarrollo]

]
.panel[.panel-name[sol]
`\begin{aligned}
  f(A,B)&amp;=\overline{A\cdot B}\\
  (1) &amp;\: \overline{\overline{A\cdot B}}\\
  (2)&amp;\: \overline{\overline{A+B}}\\
  (3)&amp;\: \overline{\overline{\bar{A}+ \bar{B}}}\\
  = &amp; \bar{A}+\bar{B}\\
\end{aligned}`
]]]

???
`\begin{aligned}
  f(A,B)&amp;=\overline{A\cdot B}\\
  (1) &amp;\: \overline{\overline{A\cdot B}}\\
  (2)&amp;\: \overline{\overline{A+B}}\\
  (3)&amp;\: \overline{\overline{\bar{A}+ \bar{B}}}\\
  = &amp; \bar{A}+\bar{B}\\
\end{aligned}`

---
# Teoremas de De Morgan - Procedimiento
.fl.w-40.pa2[
1. Complementar toda la expresión
2. Cambiar la función entre cada termino
3. Complementar cada término
]
.fl.w-60.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Reducir el circuito utilizando los teoremas de De Morgan
]
.panelset[.panel[.panel-name[desarrollo]
&lt;img src="./images/04.1/ejemplo_DeMorgan.png" width="70%" style="display: block; margin: auto;" /&gt;


]
.panel[.panel-name[sol]
`\begin{aligned}
  f(A,B,C) &amp; =\overline{A\cdot B}+\overline{c}\\
  (1)      &amp; \overline{\overline{A\cdot B}+\overline{c}}\\
  (2)      &amp; \overline{\overline{A\cdot B}\cdot \overline{c}}\\
  (3)      &amp; \overline{\overline{\overline{A\cdot B}}\cdot \overline{\overline{C}}}=\overline{A\cdot B\cdot C}\\
\end{aligned}`

]]]
???
`\begin{aligned}
  f(A,B,C) &amp; =\overline{A\cdot B}+\overline{c}\\
  (1)      &amp; \overline{\overline{A\cdot B}+\overline{c}}\\
  (2)      &amp; \overline{\overline{A\cdot B}\cdot \overline{c}}\\
  (3)      &amp; \overline{\overline{\overline{A\cdot B}}\cdot \overline{\overline{C}}}=\overline{A\cdot B\cdot C}\\
\end{aligned}`
---
class: inverse, center, middle

# Minitérminos y Maxitérminos

---
# Minitérminos 1
.fl.w-60.pa2.font80[
- **Literal:** Se define como cualquier variable que es utilizada en la tabla de verdad, pueden ser tanto las variables de entradas como sus conjugadas.
- **Minitérmino:** Es el producto de N literales, donde no pueden ser repetidos dentro de un minitéminos.
  - Los minitérminos son únicos.
  - Se simbolizan con `\(𝑚_𝑛\)` donde `\(𝑛\)` es su posición y equivale a su configuración binaria.

]
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_miniterminos.svg" width="60%" style="display: block; margin: auto;" /&gt;
]

---
# Minitérminos 2
.fl.w-60.pa2.font80[
- **Literal:** Se define como cualquier variable que es utilizada en la tabla de verdad, pueden ser tanto las variables de entradas como sus conjugadas.
- **Minitérmino:** Es el producto de N literales, donde no pueden ser repetidos dentro de un minitéminos.
  - Los minitérminos son únicos.
  - Se simbolizan con `\(𝑚_𝑛\)` donde `\(𝑛\)` es su posición y equivale a su configuración binaria.

]
.fl.w-40.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** ¿Cuál es el 11-minitérmino `\((m_{11})\)`?
]
.panelset[
.panel[.panel-name[Desarrollo]
]
.panel[.panel-name[sol]

`\begin{aligned}
  11_{10} &amp; = (1011)_2\\
  m_{11}  &amp; = a\bar{b} c d\\
\end{aligned}`

]
]]
???
`\begin{aligned}
  11_{10} &amp; = (1011)_2\\
  m_{11}  &amp; = a\bar{b} c d\\
\end{aligned}`

---
# Minitérminos 3
.fl.w-60.pa2.font70[
**Cualquier tabla de verdad** pueden representarse mediante **minitérminos** de forma directa, mediante la suma de los minitérminos positivos `\((Y=1)\)` en la salida de la tabla.
$$
\forall Y=1 \qquad ;  f(a,b,c,\dots)=\sum_n m(1,2,3,\dots ,n)
$$

Ventajas:
- Diseño sencillo
- Permite pasar desde una descripción funcional a una estructural.

Desventajas:
- El resultado no se encuentra optimizado.
  - Reducción mediante *álgebra booleana*.

]
.fl.w-40.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Encontrar la función lógica y el circuito equivalente para la tabla de verdad
]
.panelset[
.panel[.panel-name[Desarrollo]
&lt;img src="./images/04.1/tb_miniterminos.svg" width="60%" style="display: block; margin: auto;" /&gt;

]
.panel[.panel-name[sol]
`\begin{aligned}
  f(A,B) &amp; =\sum m(1, 2)\\
   &amp; = m_1+m_2\\
   &amp; = \bar{A} B+A\bar{B}\\
\end{aligned}`
]
]]

???
`\begin{aligned}
  f(A,B) &amp; =\sum m(1, 2)\\
   &amp; = m_1+m_2\\
   &amp; = \bar{A} B+A\bar{B}\\
\end{aligned}`
---
# Maxitérminos 1
.fl.w-60.pa2[
- **Maxtérmino:** Es el complemento de los minitérminos. Son una equivalencia de ellos, pero utilizando puertan OR.
- Se simbolizan con `\(M_𝑛\)` donde `\(𝑛\)` es su posición y equivale a su configuración binaria. En general
$$
m_j=\overline{Mj}
$$


]
.fl.w-40.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Comprar `\(m(A,B)\)` con `\(M(A, B)\)`
]
.panelset[
.panel[.panel-name[Desarrollo]
&lt;img src="./images/04.1/tb_comparativa.svg" width="80%" style="display: block; margin: auto;" /&gt;

]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tb_comparativa_resp.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
]]
???
&lt;img src="./images/04.1/tb_comparativa_resp.svg" width="80%" style="display: block; margin: auto;" /&gt;

---
# Maxitérminos 2
Cada maxitérmino se obtiene de un término OR de las n variables, donde cada variable lleva un
apóstrofo si el bit correspondiente del número binario es 1.

El procedimiento para obtener el producto de maxitérminos:
- Se forma un maxitérmino para cada combinación de las variables que produce un 0 en la función y luego se hace el AND de todos esos maxitérminos. 

$$
\forall Y=1; \qquad   f(a,b,c,\dots)=\prod_n M(1,2,3,\dots ,n)
$$
--
En otras palabras **los maxitérminos es negar los ceros de salidas al utilizar minitérminos!!!**

---
class: clear

.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font60[
**Ejemplo**
1. Encontrar los minitérminos y maxitérminos de la tabla de verdad. 
2. Crear una función alternativa usando los ceros de salida
3. Aplicar De Morgan a la función encontrada en (2) y comprar con maxitérminos
]

.panelset[
.panel[.panel-name[desarrollo]
.fl.w-50.pa2[
&lt;img src="./images/04.1/ejemplo_maxi.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[]


]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/ejemplo_maxi_sol.svg" width="50%" style="display: block; margin: auto;" /&gt;
]

]
???
&lt;img src="./images/04.1/ejemplo_maxtermino_sol.png" width="80%" style="display: block; margin: auto;" /&gt;

---
# Aplicación: XOR y XNOR
**XOR**: OR exclusivo, es 1 en su salida solamente cuando una de sus entradas es 1.
**XNOR**: No XOR.

.fl.w-50.pa2[
&lt;img src="./images/04.1/XOR.png" width="50%" style="display: block; margin: auto;" /&gt;

.panelset[
.panel[.panel-name[desarrollo]
&lt;img src="./images/04.1/tb_2x2.svg" width="40%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tb_XOR.svg" width="40%" style="display: block; margin: auto;" /&gt;
$$
  Y(A,B)=\bar{A}B+A\bar{B}
$$

]]]

.fl.w-50.pa2[
&lt;img src="./images/04.1/XNOR.png" width="50%" style="display: block; margin: auto;" /&gt;

.panelset[
.panel[.panel-name[desarrollo]
&lt;img src="./images/04.1/tb_2x2.svg" width="40%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tb_XNOR.svg" width="40%" style="display: block; margin: auto;" /&gt;
$$
  Y(A,B)=\overline{AB}+AB
$$

]]]
???
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_XOR.svg" width="40%" style="display: block; margin: auto;" /&gt;
$$
  Y(A,B)=\bar{A}B+A\bar{B}
$$
]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_XNOR.svg" width="40%" style="display: block; margin: auto;" /&gt;
$$
  Y(A,B)=\overline{AB}+AB
$$
]




---

# Medio Sumador binario
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font60[
1. Construir la tabla de verdad de un sumador binario de *dos números enteros binarios* de  1 bit cada uno.
2. Utilizar minitérminos encontrar su función booleana y circuito combinacional.
]

.panelset[
.panel[.panel-name[desarrollo 1]]
.panel[.panel-name[desarrollo 2]
&lt;img src="./images/04.1/tb_mediosumador.svg" width="40%" style="display: block; margin: auto;" /&gt;

]
.panel[.panel-name[res]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_mediosumador_resp.svg" width="60%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[

&lt;img src="./images/04.1/esquema_mediosumador.png" width="90%" style="display: block; margin: auto;" /&gt;
$$
S=A\bar{B}+\bar{A}=A\oplus B\\
Ac=AB
$$
]]]

???
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_mediosumador_resp.svg" width="60%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[

&lt;img src="./images/04.1/esquema_mediosumador.png" width="90%" style="display: block; margin: auto;" /&gt;
$$
S=A\bar{B}+\bar{A}=A\oplus B\\
Ac=AB
$$
]

---
# Aplicación: Sumador completo binario
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font60[
1. Construir la tabla de verdad de un sumador binario de *dos números enteros binarios con acarreo de entrada* de  1 bit cada uno.
2. Utilizar minitérminos encontrar su función booleana y circuito combinacional.
]

.panelset[
.panel[.panel-name[desarrollo 1]]
.panel[.panel-name[desarrollo 2]
&lt;img src="./images/04.1/tb_sumadorcompleto.svg" width="40%" style="display: block; margin: auto;" /&gt;

]
.panel[.panel-name[res]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_sumadorcompleto_resp.svg" width="60%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[

&lt;img src="./images/04.1/esquema_sumador_completo.png" width="90%" style="display: block; margin: auto;" /&gt;
$$
S=Cin \oplus(A\oplus B)\\
Cout=Cin(A\oplus B)+AB
$$
]]]

???
.fl.w-50.pa2[
&lt;img src="./images/04.1/ejemplo_sumadorcompleto_resp.png" width="80%" style="display: block; margin: auto;" /&gt;
]

.fl.w-50.pa2[
&lt;img src="./images/04.1/esquema_sumador_completo.png" width="90%" style="display: block; margin: auto;" /&gt;

]


---
# Conexión es cascada
En algunos diseños digitales es conveniente pensar las operaciones de ***forma modular***. Por ejemplo, el sumador completo puede ser empaquetado como: 

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./images/04.1/cascada_sumador.png" alt="COnexión en cascada sumadores completo. Diseño digital - Morris Mano" width="80%" /&gt;
&lt;p class="caption"&gt;COnexión en cascada sumadores completo. Diseño digital - Morris Mano&lt;/p&gt;
&lt;/div&gt;


---
---
class: inverse, center, middle

# Mapas de Karnaugh
---

# Mapas de Karnaugh (k-map)
.fl.w-60.pa2[

- Es un a representación gráfica de los mini/maxi términos.
  -   Obtenemos gráficamente todas las posibles formas de representar una función lógica.
- Permite inspeccionar y seleccionar la configuración idónea para nuestros circuitos combionacionales.
encontrar la función booleana desde una tabla de verdad.
- La función encontrada la función ya minimizada!!!.

- Desventaja: problemas cuando son muchas entradas en el circuito.
]
.fl.w-40.pa2[
.rojo[COlocar imagen de referencia]
]

---
# k-map - consideraciones
- Cada Minitérmino del mapa-K difiere de su vecino en un literal.
- Cuando agrupemos minitérminos en los mapas-K, estos grupos tienen que estar constituidos por potencias de 2.
- Cada grupo debe posee la mayor cantidad de minitérminos para reducir la cantidad de literales utilizados en el circuito.
- Se tiene que buscar/utilizar la menor cantidad de grupos en los mapas. Los minitérminos pueden ser utilizadas en más de un grupo.

---
# k-map de 2 variables - 1
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_2x2_kmap_or.svg" width="80%" style="display: block; margin: auto;" /&gt;


]
.fl.w-30.pa2[
$$
Y(A, B) = \sum m(1, 2, 3)
$$
]
.fl.w-30.pa2[
&lt;img src="./images/04.1/tab/kmap 2x2.svg" width="50%" style="display: block; margin: auto;" /&gt;

&lt;img src="./images/04.1/tab/kmap or.svg" width="50%" style="display: block; margin: auto;" /&gt;

]


---
# k-map de 2 variables - 2
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_2x2_kmap_or.svg" width="80%" style="display: block; margin: auto;" /&gt;

$$
Y(A, B) = \sum m(1, 2, 3)
$$

]
.fl.w-60.pa2[
.fl.w-60.pa2.font80[
1) Para 2 variables (x, y) ordenamos los minitérminos.
]
.fl.w-40.pa2[
&lt;img src="./images/04.1/tab/kmap 2x2.svg" width="50%" style="display: block; margin: auto;" /&gt;
]

.font80[
2) Filas para 𝑥 y columnas para 𝑦. Reemplazamos Los valores de 𝑓 en el mapa-K
]
.fl.w-50.pa2[

&lt;img src="./images/04.1/tab/kmap 2x2 v2.svg" width="50%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tab/kmap 2x2 v3.svg" width="50%" style="display: block; margin: auto;" /&gt;

]]

---
# k-map de 2 variables - 3
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_2x2_kmap_or.svg" width="80%" style="display: block; margin: auto;" /&gt;

.font70[
$$
Y(A,B) = \sum m(1, 2, 3) = A+B
$$
]

]
.fl.w-60.pa2[
.font80[
3) Agrupamos minitérminos 1 en grupos de 1 o potencias de 2
]

.fl.w-50.pa2[

&lt;img src="./images/04.1/tab/kmap or v1.svg" width="50%" style="display: block; margin: auto;" /&gt;
.font70[
$$
Y(A,B)=A\bar{B}+\bar{A}B+AB
$$
]

]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tab/kmap or v2.svg" width="50%" style="display: block; margin: auto;" /&gt;
.font70[
$$
Y(A,B)=A+\bar{A}B+AB
$$
]
]

&lt;img src="./images/04.1/tab/kmap or v3.svg" width="20%" style="display: block; margin: auto;" /&gt;

.font70[
$$
Y(A,B)=A+B
$$

]
]

---
# k-map de 3 variables - 1
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_3x3_kmap.svg" width="80%" style="display: block; margin: auto;" /&gt;


$$
Y(A,B,C)=\sum m(0,1)
$$

]
.fl.w-60.pa2[
1. Agrupamos dos variables en las columnas y una en las filas. Para formar las combinaciones de las columnas, partimos de cualquier combinación (en este caso 00). 

Las combinaciones siguientes solo pueden cambiar un bit respecto a su compañero:

&lt;img src="./images/04.1/tab/ej 3x3 kmap.svg" width="80%" style="display: block; margin: auto;" /&gt;

]

]


---
# Bibliografía
- Capítulo 3 – Formas de Onda y Lógica Booleana. Sección 3.1-3.7. Bignell, James W., et al. Electrónica digital.
- Capítulo 2  – Álgebra booleana y compuertas lógicas. Sección 2.1-2.7. M. Morris Mano, Diseño Digital. Pearson Edutacion.
- Capítulo 2  – Álgebra booleana y compuertas lógicas. Sección 2.1-2.2, 2.4. Victor P. Nelson, Análisis y Diseño de Circuitos Lógicos Digitales. Pearson.

Profundizar
- Cap. 4 Álgebra de boole y Simplificacióñ lógica. Floyd, Thomas L. Fundamentos de sistemas digitales. Prentice Hall, 2006.


---
# Aplicaciones
- Restador
- Display 7 segmentos
- Multiplexor
- Demultiplexor
- Codificador
- Decodificador
- Generadores / comprobadores de paridad

Las presentación son en pareja con una duración entre ***5 a 10 min***
---
class: inverse, middle, center

[**Próxima clase:** Lógica Combinacional - Aplicaciones]()


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"countIncrementalSlides": true,
"ratio": "16:9",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>`\n"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
