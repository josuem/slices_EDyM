<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>L√≥gica combinacional</title>
    <meta charset="utf-8" />
    <meta name="author" content="Josu√© Meneses D√≠az" />
    <meta name="author" content="josue.meneses@usach.cl" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/fabric/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/xaringanExtra-extra-styles/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/fira_sans.css" type="text/css" />
    <link rel="stylesheet" href="css/fira_code.css" type="text/css" />
    <link rel="stylesheet" href="css/personal.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# L√≥gica combinacional
## Electr√≥nica digital y microcontroladores
### Josu√© Meneses D√≠az
### <a href="mailto:josue.meneses@usach.cl" class="email">josue.meneses@usach.cl</a>
### Universidad de Santiago de Chile
### 04-06-2021

---


# Objetivos 
&lt;br&gt; &lt;br&gt;
- Conocer los principios de los fundamentos del algebra booleana.
  - Teoremas Booleanos
  - Teoremas De Morgan
- M√©todos de Dise√±o para Circuitos combinacionales 
  - Algebra Booleana
  - M√©todo 1. Minterm/Maxterm
  - M√©todo 2. Mapas de Karnaugh

---
# Logica combinacional
.fl.w-50.pa2[
&lt;br&gt; &lt;br&gt;
- Es aquel circuito l√≥gico que implementa una o varias funciones l√≥gicas.
  - Entradas 0, 1 -&gt; Salidas  0, 1
&lt;br&gt;
- Las salidas solo dependen de las entradas del sistema.
  - **NO TIENE MEMORIA**
]

.fl.w-50.pa2[
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./images/02.2/7402.png" alt="Esquema Puerta l√≥gica 7402" width="60%" /&gt;
&lt;p class="caption"&gt;Esquema Puerta l√≥gica 7402&lt;/p&gt;
&lt;/div&gt;
]
---
# Descripci√≥n Estructural
.fl.w-40.pa2[
- Describe como se encuentra internamente definido un circuito l√≥gico combinacional por medio de puertas l√≥gicas.
- Nos permite encontrar ***una*** la funci√≥n booleana del sistema de forma simple.
]
.fl.w-60.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Encontrar una expresi√≥n en la salida de las puertas (Y)
]

&lt;img src="./images/04.1/ejemplo1.png" width="60%" style="display: block; margin: auto;" /&gt;

]
???
$$
f(A,B,C)=A\cdot B\cdot \bar{C}+\bar{A}\cdot B\cdot C
$$
---
# Tipos de descripciones
.fl.w-50.pa2[
## Descripci√≥n Estructural
&lt;img src="./images/04.1/ejemplo1.png" width="60%" style="display: block; margin: auto;" /&gt;
&lt;br&gt; &lt;br&gt;
$$
f(A,B,C)=A\cdot B\cdot \bar{C}+\bar{A}\cdot B\cdot C
$$
]


.fl.w-50.pa2[
## Descripci√≥n Funcional
.panelset[
.panel[.panel-name[Tabla]
&lt;img src="./images/04.1/tb1.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tb1_resp.svg" width="80%" style="display: block; margin: auto;" /&gt;
]]
]
???
&lt;img src="./images/04.1/tb1_resp.svg" width="80%" style="display: block; margin: auto;" /&gt;
---
class: clear, center, middle

.font120[**¬øC√≥mo podemos pasar de una descripci√≥n funcional a una estructural?**]

--

.font120[**¬øC√≥mo podemos deducimos una funci√≥n booleana desde una tabla de verdad?**]

--
.fl.w-40.pa2[
- Minit√©rminos/Maxit√©rminos   
- Mapas de Karnaugh (k-maps)
]
.fl.w-60.pa2[
&lt;img src="./images/04.1/esquema1.svg" width="60%" style="display: block; margin: auto;" /&gt;

]

---
class: inverse, middle, center
# Algebra booleana

---
# Teoremas Booleanos
Son los teoremas que conocemos de √°lgebra, ahora aplicados sobre circuitos l√≥gicos.

.fl.w-60.pa2[

&lt;img src="./images/04.1/teoremas_booleanos.svg" width="140%" style="display: block; margin: auto;" /&gt;
]

---
# Teoremas de De Morgan
## T1. `\(\overline{A\cdot B}=\bar{A}+\bar{B}\)`
.fl.w-60.pa2[
.panelset[.panel[.panel-name[DeMorgan 1]
&lt;img src="./images/04.1/tbDeMorgan_T1.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tbDeMorgan_T1_sol.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
]]

.fl.w-40.pa2[
&lt;img src="./images/04.1/DeMorgan_T1.png" width="80%" style="display: block; margin: auto;" /&gt;
]
???
&lt;img src="./images/04.1/tbDeMorgan_T1_sol.svg" width="80%" style="display: block; margin: auto;" /&gt;

---
# Teoremas de De Morgan
## T2. `\(\overline{ A+B}=\bar{A}\cdot \bar{B}\)`
.fl.w-60.pa2[
.panelset[.panel[.panel-name[DeMorgan 2]
&lt;img src="./images/04.1/tbDeMorgan_T2.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tbDeMorgan_T2_sol.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
]]

.fl.w-40.pa2[
&lt;img src="./images/04.1/DeMorgan_T2.png" width="80%" style="display: block; margin: auto;" /&gt;
]
???
&lt;img src="./images/04.1/tbDeMorgan_T2_sol.svg" width="80%" style="display: block; margin: auto;" /&gt;
---
# Teoremas de De Morgan - Procedimiento
.fl.w-40.pa2[
1. Complementar toda la expresi√≥n
2. Cambiar la funci√≥n entre cada termino
3. Complementar cada t√©rmino
]
.fl.w-60.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Aplicar los teoremas de De Morgan a la expresi√≥n `\(ùê¥+ùêµ\)`. Dibuje ambos esquemas equivalentes.
]
.panelset[.panel[.panel-name[desarrollo]

]
.panel[.panel-name[sol]

`\begin{aligned}
  f(A,B)&amp;=A+B=\overline{\bar{A}\cdot \bar{B}}\\
  (1) &amp;\: \overline{A+B}\\
  (2)&amp;\: \overline{A\cdot B}\\
  (3)&amp;\: \overline{\bar{A}\cdot \bar{B}}\\
\end{aligned}`

]]]
???
`\begin{aligned}
  f(A,B)&amp;=A+B=\overline{\bar{A}\cdot \bar{B}}\\
  (1) &amp;\: \overline{A+B}\\
  (2)&amp;\: \overline{A\cdot B}\\
  (3)&amp;\: \overline{\bar{A}\cdot \bar{B}}\\
\end{aligned}`
---
# Teoremas de De Morgan - Procedimiento
.fl.w-40.pa2[
1. Complementar toda la expresi√≥n
2. Cambiar la funci√≥n entre cada termino
3. Complementar cada t√©rmino
]
.fl.w-60.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Aplicar los teoremas de De Morgan a la expresi√≥n `\(\overline{ùê¥\cdotùêµ}\)`. Dibuje ambos esquemas equivalentes.
]
.panelset[.panel[.panel-name[desarrollo]

]
.panel[.panel-name[sol]
`\begin{aligned}
  f(A,B)&amp;=\overline{A\cdot B}\\
  (1) &amp;\: \overline{\overline{A\cdot B}}\\
  (2)&amp;\: \overline{\overline{A+B}}\\
  (3)&amp;\: \overline{\overline{\bar{A}+ \bar{B}}}\\
  = &amp; \bar{A}+\bar{B}\\
\end{aligned}`
]]]

???
`\begin{aligned}
  f(A,B)&amp;=\overline{A\cdot B}\\
  (1) &amp;\: \overline{\overline{A\cdot B}}\\
  (2)&amp;\: \overline{\overline{A+B}}\\
  (3)&amp;\: \overline{\overline{\bar{A}+ \bar{B}}}\\
  = &amp; \bar{A}+\bar{B}\\
\end{aligned}`

---
# Teoremas de De Morgan - Procedimiento
.fl.w-40.pa2[
1. Complementar toda la expresi√≥n
2. Cambiar la funci√≥n entre cada termino
3. Complementar cada t√©rmino
]
.fl.w-60.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Reducir el circuito utilizando los teoremas de De Morgan
]
.panelset[.panel[.panel-name[desarrollo]
&lt;img src="./images/04.1/ejemplo_DeMorgan.png" width="70%" style="display: block; margin: auto;" /&gt;


]
.panel[.panel-name[sol]
`\begin{aligned}
  f(A,B,C) &amp; =\overline{A\cdot B}+\overline{c}\\
  (1)      &amp; \overline{\overline{A\cdot B}+\overline{c}}\\
  (2)      &amp; \overline{\overline{A\cdot B}\cdot \overline{c}}\\
  (3)      &amp; \overline{\overline{\overline{A\cdot B}}\cdot \overline{\overline{C}}}=\overline{A\cdot B\cdot C}\\
\end{aligned}`

]]]
???
`\begin{aligned}
  f(A,B,C) &amp; =\overline{A\cdot B}+\overline{c}\\
  (1)      &amp; \overline{\overline{A\cdot B}+\overline{c}}\\
  (2)      &amp; \overline{\overline{A\cdot B}\cdot \overline{c}}\\
  (3)      &amp; \overline{\overline{\overline{A\cdot B}}\cdot \overline{\overline{C}}}=\overline{A\cdot B\cdot C}\\
\end{aligned}`
---
class: inverse, center, middle

# Minit√©rminos y Maxit√©rminos

---
# Minit√©rminos 1
.fl.w-60.pa2.font80[
- **Literal:** Se define como cualquier variable que es utilizada en la tabla de verdad, pueden ser tanto las variables de entradas como sus conjugadas.
- **Minit√©rmino:** Es el producto de N literales, donde no pueden ser repetidos dentro de un minit√©minos.
  - Los minit√©rminos son √∫nicos.
  - Se simbolizan con `\(ùëö_ùëõ\)` donde `\(ùëõ\)` es su posici√≥n y equivale a su configuraci√≥n binaria.

]
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_miniterminos.svg" width="60%" style="display: block; margin: auto;" /&gt;
]

---
# Minit√©rminos 2
.fl.w-60.pa2.font80[
- **Literal:** Se define como cualquier variable que es utilizada en la tabla de verdad, pueden ser tanto las variables de entradas como sus conjugadas.
- **Minit√©rmino:** Es el producto de N literales, donde no pueden ser repetidos dentro de un minit√©minos.
  - Los minit√©rminos son √∫nicos.
  - Se simbolizan con `\(ùëö_ùëõ\)` donde `\(ùëõ\)` es su posici√≥n y equivale a su configuraci√≥n binaria.

]
.fl.w-40.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** ¬øCu√°l es el 11-minit√©rmino `\((m_{11})\)`?
]
.panelset[
.panel[.panel-name[Desarrollo]
]
.panel[.panel-name[sol]

`\begin{aligned}
  11_{10} &amp; = (1011)_2\\
  m_{11}  &amp; = a\bar{b} c d\\
\end{aligned}`

]
]]
???
`\begin{aligned}
  11_{10} &amp; = (1011)_2\\
  m_{11}  &amp; = a\bar{b} c d\\
\end{aligned}`

---
# Minit√©rminos 3
.fl.w-60.pa2.font70[
**Cualquier tabla de verdad** pueden representarse mediante **minit√©rminos** de forma directa, mediante la suma de los minit√©rminos positivos `\((Y=1)\)` en la salida de la tabla.
$$
\forall Y=1 \qquad ;  f(a,b,c,\dots)=\sum_n m(1,2,3,\dots ,n)
$$

Ventajas:
- Dise√±o sencillo
- Permite pasar desde una descripci√≥n funcional a una estructural.

Desventajas:
- El resultado no se encuentra optimizado.
  - Reducci√≥n mediante *√°lgebra booleana*.

]
.fl.w-40.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Encontrar la funci√≥n l√≥gica y el circuito equivalente para la tabla de verdad
]
.panelset[
.panel[.panel-name[Desarrollo]
&lt;img src="./images/04.1/tb_miniterminos.svg" width="60%" style="display: block; margin: auto;" /&gt;

]
.panel[.panel-name[sol]
`\begin{aligned}
  f(A,B) &amp; =\sum m(1, 2)\\
   &amp; = m_1+m_2\\
   &amp; = \bar{A} B+A\bar{B}\\
\end{aligned}`
]
]]

???
`\begin{aligned}
  f(A,B) &amp; =\sum m(1, 2)\\
   &amp; = m_1+m_2\\
   &amp; = \bar{A} B+A\bar{B}\\
\end{aligned}`
---
# Maxit√©rminos 1
.fl.w-60.pa2[
- **Maxt√©rmino:** Es el complemento de los minit√©rminos. Son una equivalencia de ellos, pero utilizando puertan OR.
- Se simbolizan con `\(M_ùëõ\)` donde `\(ùëõ\)` es su posici√≥n y equivale a su configuraci√≥n binaria. En general
$$
m_j=\overline{Mj}
$$


]
.fl.w-40.pa2[
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font80[
**Ejemplo** Comprar `\(m(A,B)\)` con `\(M(A, B)\)`
]
.panelset[
.panel[.panel-name[Desarrollo]
&lt;img src="./images/04.1/tb_comparativa.svg" width="80%" style="display: block; margin: auto;" /&gt;

]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tb_comparativa_resp.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
]]
???
&lt;img src="./images/04.1/tb_comparativa_resp.svg" width="80%" style="display: block; margin: auto;" /&gt;

---
# Maxit√©rminos 2
Cada maxit√©rmino se obtiene de un t√©rmino OR de las n variables, donde cada variable lleva un
ap√≥strofo si el bit correspondiente del n√∫mero binario es 1.

El procedimiento para obtener el producto de maxit√©rminos:
- Se forma un maxit√©rmino para cada combinaci√≥n de las variables que produce un 0 en la funci√≥n y luego se hace el AND de todos esos maxit√©rminos. 

$$
\forall Y=1; \qquad   f(a,b,c,\dots)=\prod_n M(1,2,3,\dots ,n)
$$
--
En otras palabras **los maxit√©rminos es negar los ceros de salidas al utilizar minit√©rminos!!!**

---
class: clear

.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font60[
**Ejemplo**
1. Encontrar los minit√©rminos y maxit√©rminos de la tabla de verdad. 
2. Crear una funci√≥n alternativa usando los ceros de salida
3. Aplicar De Morgan a la funci√≥n encontrada en (2) y comprar con maxit√©rminos
]

.panelset[
.panel[.panel-name[desarrollo]
.fl.w-50.pa2[
&lt;img src="./images/04.1/ejemplo_maxi.svg" width="80%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[]


]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/ejemplo_maxi_sol.svg" width="50%" style="display: block; margin: auto;" /&gt;
]

]
???
&lt;img src="./images/04.1/ejemplo_maxtermino_sol.png" width="80%" style="display: block; margin: auto;" /&gt;

---
# Aplicaci√≥n: XOR y XNOR
**XOR**: OR exclusivo, es 1 en su salida solamente cuando una de sus entradas es 1.
**XNOR**: No XOR.

.fl.w-50.pa2[
&lt;img src="./images/04.1/XOR.png" width="50%" style="display: block; margin: auto;" /&gt;

.panelset[
.panel[.panel-name[desarrollo]
&lt;img src="./images/04.1/tb_2x2.svg" width="40%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tb_XOR.svg" width="40%" style="display: block; margin: auto;" /&gt;
$$
  Y(A,B)=\bar{A}B+A\bar{B}
$$

]]]

.fl.w-50.pa2[
&lt;img src="./images/04.1/XNOR.png" width="50%" style="display: block; margin: auto;" /&gt;

.panelset[
.panel[.panel-name[desarrollo]
&lt;img src="./images/04.1/tb_2x2.svg" width="40%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[sol]
&lt;img src="./images/04.1/tb_XNOR.svg" width="40%" style="display: block; margin: auto;" /&gt;
$$
  Y(A,B)=\overline{AB}+AB
$$

]]]
???
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_XOR.svg" width="40%" style="display: block; margin: auto;" /&gt;
$$
  Y(A,B)=\bar{A}B+A\bar{B}
$$
]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_XNOR.svg" width="40%" style="display: block; margin: auto;" /&gt;
$$
  Y(A,B)=\overline{AB}+AB
$$
]




---

# Medio Sumador binario
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font60[
1. Construir la tabla de verdad de un sumador binario de *dos n√∫meros enteros binarios* de  1 bit cada uno.
2. Utilizar minit√©rminos encontrar su funci√≥n booleana y circuito combinacional.
]

.panelset[
.panel[.panel-name[desarrollo 1]]
.panel[.panel-name[desarrollo 2]
&lt;img src="./images/04.1/tb_mediosumador.svg" width="40%" style="display: block; margin: auto;" /&gt;

]
.panel[.panel-name[res]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_mediosumador_resp.svg" width="60%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[

&lt;img src="./images/04.1/esquema_mediosumador.png" width="90%" style="display: block; margin: auto;" /&gt;
$$
S=A\bar{B}+\bar{A}=A\oplus B\\
Ac=AB
$$
]]]

???
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_mediosumador_resp.svg" width="60%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[

&lt;img src="./images/04.1/esquema_mediosumador.png" width="90%" style="display: block; margin: auto;" /&gt;
$$
S=A\bar{B}+\bar{A}=A\oplus B\\
Ac=AB
$$
]

---
# Aplicaci√≥n: Sumador completo binario
.bg-lightest-blue.b--dark-blue.ba.bw2.br4.ph2.font60[
1. Construir la tabla de verdad de un sumador binario de *dos n√∫meros enteros binarios con acarreo de entrada* de  1 bit cada uno.
2. Utilizar minit√©rminos encontrar su funci√≥n booleana y circuito combinacional.
]

.panelset[
.panel[.panel-name[desarrollo 1]]
.panel[.panel-name[desarrollo 2]
&lt;img src="./images/04.1/tb_sumadorcompleto.svg" width="40%" style="display: block; margin: auto;" /&gt;

]
.panel[.panel-name[res]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tb_sumadorcompleto_resp.svg" width="60%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[

&lt;img src="./images/04.1/esquema_sumador_completo.png" width="90%" style="display: block; margin: auto;" /&gt;
$$
S=Cin \oplus(A\oplus B)\\
Cout=Cin(A\oplus B)+AB
$$
]]]

???
.fl.w-50.pa2[
&lt;img src="./images/04.1/ejemplo_sumadorcompleto_resp.png" width="80%" style="display: block; margin: auto;" /&gt;
]

.fl.w-50.pa2[
&lt;img src="./images/04.1/esquema_sumador_completo.png" width="90%" style="display: block; margin: auto;" /&gt;

]


---
# Conexi√≥n es cascada
En algunos dise√±os digitales es conveniente pensar las operaciones de ***forma modular***. Por ejemplo, el sumador completo puede ser empaquetado como: 

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./images/04.1/cascada_sumador.png" alt="COnexi√≥n en cascada sumadores completo. Dise√±o digital - Morris Mano" width="80%" /&gt;
&lt;p class="caption"&gt;COnexi√≥n en cascada sumadores completo. Dise√±o digital - Morris Mano&lt;/p&gt;
&lt;/div&gt;


---
---
class: inverse, center, middle

# Mapas de Karnaugh
---

# Mapas de Karnaugh (k-map)
.fl.w-60.pa2[

- Es un a representaci√≥n gr√°fica de los mini/maxi t√©rminos.
  -   Obtenemos gr√°ficamente todas las posibles formas de representar una funci√≥n l√≥gica.
- Permite inspeccionar y seleccionar la configuraci√≥n id√≥nea para nuestros circuitos combionacionales.
encontrar la funci√≥n booleana desde una tabla de verdad.
- La funci√≥n encontrada la funci√≥n ya minimizada!!!.

- Desventaja: problemas cuando son muchas entradas en el circuito.
]
.fl.w-40.pa2[
.rojo[COlocar imagen de referencia]
]

---
# k-map - consideraciones
- Cada Minit√©rmino del mapa-K difiere de su vecino en un literal.
- Cuando agrupemos minit√©rminos en los mapas-K, estos grupos tienen que estar constituidos por potencias de 2.
- Cada grupo debe posee la mayor cantidad de minit√©rminos para reducir la cantidad de literales utilizados en el circuito.
- Se tiene que buscar/utilizar la menor cantidad de grupos en los mapas. Los minit√©rminos pueden ser utilizadas en m√°s de un grupo.

---
# k-map de 2 variables - 1
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_2x2_kmap_or.svg" width="80%" style="display: block; margin: auto;" /&gt;


]
.fl.w-30.pa2[
$$
Y(A, B) = \sum m(1, 2, 3)
$$
]
.fl.w-30.pa2[
&lt;img src="./images/04.1/tab/kmap 2x2.svg" width="50%" style="display: block; margin: auto;" /&gt;

&lt;img src="./images/04.1/tab/kmap or.svg" width="50%" style="display: block; margin: auto;" /&gt;

]


---
# k-map de 2 variables - 2
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_2x2_kmap_or.svg" width="80%" style="display: block; margin: auto;" /&gt;

$$
Y(A, B) = \sum m(1, 2, 3)
$$

]
.fl.w-60.pa2[
.fl.w-60.pa2.font80[
1) Para 2 variables (x, y) ordenamos los minit√©rminos.
]
.fl.w-40.pa2[
&lt;img src="./images/04.1/tab/kmap 2x2.svg" width="50%" style="display: block; margin: auto;" /&gt;
]

.font80[
2) Filas para ùë• y columnas para ùë¶. Reemplazamos Los valores de ùëì en el mapa-K
]
.fl.w-50.pa2[

&lt;img src="./images/04.1/tab/kmap 2x2 v2.svg" width="50%" style="display: block; margin: auto;" /&gt;
]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tab/kmap 2x2 v3.svg" width="50%" style="display: block; margin: auto;" /&gt;

]]

---
# k-map de 2 variables - 3
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_2x2_kmap_or.svg" width="80%" style="display: block; margin: auto;" /&gt;

.font70[
$$
Y(A,B) = \sum m(1, 2, 3) = A+B
$$
]

]
.fl.w-60.pa2[
.font80[
3) Agrupamos minit√©rminos 1 en grupos de 1 o potencias de 2
]

.fl.w-50.pa2[

&lt;img src="./images/04.1/tab/kmap or v1.svg" width="50%" style="display: block; margin: auto;" /&gt;
.font70[
$$
Y(A,B)=A\bar{B}+\bar{A}B+AB
$$
]

]
.fl.w-50.pa2[
&lt;img src="./images/04.1/tab/kmap or v2.svg" width="50%" style="display: block; margin: auto;" /&gt;
.font70[
$$
Y(A,B)=A+\bar{A}B+AB
$$
]
]

&lt;img src="./images/04.1/tab/kmap or v3.svg" width="20%" style="display: block; margin: auto;" /&gt;

.font70[
$$
Y(A,B)=A+B
$$

]
]

---
# k-map de 3 variables - 1
.fl.w-40.pa2[
&lt;img src="./images/04.1/tb_3x3_kmap.svg" width="80%" style="display: block; margin: auto;" /&gt;


$$
Y(A,B,C)=\sum m(0,1)
$$

]
.fl.w-60.pa2[
1. Agrupamos dos variables en las columnas y una en las filas. Para formar las combinaciones de las columnas, partimos de cualquier combinaci√≥n (en este caso 00). 

Las combinaciones siguientes solo pueden cambiar un bit respecto a su compa√±ero:

&lt;img src="./images/04.1/tab/ej 3x3 kmap.svg" width="80%" style="display: block; margin: auto;" /&gt;

]

]


---
# Bibliograf√≠a
- Cap√≠tulo 3 ‚Äì Formas de Onda y L√≥gica Booleana. Secci√≥n 3.1-3.7. Bignell, James W., et al. Electr√≥nica digital.
- Cap√≠tulo 2  ‚Äì √Ålgebra booleana y compuertas l√≥gicas. Secci√≥n 2.1-2.7. M. Morris Mano, Dise√±o Digital. Pearson Edutacion.
- Cap√≠tulo 2  ‚Äì √Ålgebra booleana y compuertas l√≥gicas. Secci√≥n 2.1-2.2, 2.4. Victor P. Nelson, An√°lisis y Dise√±o de Circuitos L√≥gicos Digitales. Pearson.

Profundizar
- Cap. 4 √Ålgebra de boole y Simplificaci√≥√± l√≥gica. Floyd, Thomas L. Fundamentos de sistemas digitales. Prentice Hall, 2006.


---
# Aplicaciones
- Restador
- Display 7 segmentos
- Multiplexor
- Demultiplexor
- Codificador
- Decodificador
- Generadores / comprobadores de paridad

Las presentaci√≥n son en pareja con una duraci√≥n entre ***5 a 10 min***
---
class: inverse, middle, center

[**Pr√≥xima clase:** L√≥gica Combinacional - Aplicaciones]()


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"countIncrementalSlides": true,
"ratio": "16:9",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>`\n"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
